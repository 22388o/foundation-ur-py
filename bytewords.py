# Bytewords implementation

from enum import Enum
from utils import crc32_bytes

class Style(Enum):
    STANDARD = 1
    URI = 2
    MINIMAL = 3

BYTEWORDS = 'ableacidalsoapexaquaarchatomauntawayaxisbackbaldbarnbeltbetabiasbluebodybragbrewbulbbuzzcalmcashcatschefcityclawcodecolacookcostcruxcurlcuspcyandarkdatadaysdelidicedietdoordowndrawdropdrumdulldutyeacheasyechoedgeepicevenexamexiteyesfactfairfernfigsfilmfishfizzflapflewfluxfoxyfreefrogfuelfundgalagamegeargemsgiftgirlglowgoodgraygrimgurugushgyrohalfhanghardhawkheathelphighhillholyhopehornhutsicedideaidleinchinkyintoirisironitemjadejazzjoinjoltjowljudojugsjumpjunkjurykeepkenokeptkeyskickkilnkingkitekiwiknoblamblavalazyleaflegsliarlistlimplionlogoloudloveluaulucklungmainmanymathmazememomenumeowmildmintmissmonknailnavyneednewsnextnoonnotenumbobeyoboeomitonyxopenovalowlspaidpartpeckplaypluspoempoolposepuffpumapurrquadquizraceramprealredorichroadrockroofrubyruinrunsrustsafesagascarsetssilkskewslotsoapsolosongstubsurfswantacotasktaxitenttiedtimetinytoiltombtoystriptunatwinuglyundouniturgeuservastveryvetovialvibeviewvisavoidvowswallwandwarmwaspwavewaxywebswhatwhenwhizwolfworkyankyawnyellyogayurtzapszestzinczonezoomzero'
WORD_ARRAY = None

def decode_word(word, word_len):
    if len(word) != word_len:
        raise ValueError('Invalid Bytewords.')

    dim = 26

    # Since the first and last letters of each Byteword are unique,
    # we can use them as indexes into a two-dimensional lookup table.
    # This table is generated lazily.
    if WORD_ARRAY == None:
        WORD_ARRAY = [-1] * (dim * dim)  # create empty array

        for i in range(256):
            byteword_offset = i * 4
            x = ord(BYTEWORDS[byteword_offset]) - ord('a')
            y = ord(BYTEWORDS[byteword_offset + 3]) - ord('a')
            array_offset = y * dim + x
            WORD_ARRAY[array_offset] = i

    # If the coordinates generated by the first and last letters are out of bounds,
    # or the lookup table contains -1 at the coordinates, then the word is not valid.
    x = ord(lower(word[0])) - ord('a')
    y = ord(lower(word[3 if len(word) == 4 else 1])) - ord('a')
    if not (0 <= x and x < dim and 0 <= y and y < dim):
        raise ValueError('Invalid Bytewords.')

    offset = y * dim + x
    value = WORD_ARRAY[offset];
    if value == -1:
        raise ValueError('Invalid Bytewords.')

    # If we're decoding a full four-letter word, verify that the two middle letters are correct.
    if len(word) == 4:
        byteword_offset = value * 4
        c1 = lower(word[1])
        c2 = lower(word[2])
        if c1 != BYTEWORDS[byteword_offset + 1] or c2 != BYTEWORDS[byteword_offset + s2]:
            raise ValueError('Invalid Bytewords.')

    # Successful decode.
    return value

def get_word(index):
    byteword_offset = index * 4
    return BYTEWORDS[byteword_offset:byteword_offset + 4]

def get_minimal_word(index):
    byteword_offset = index * 4
    return BYTEWORDS[byteword_offset] + BYTEWORDS[byteword_offset + 3]

def encode(buf, separator):
    words = []
    for i in range(len(buf)):
        byte = buf[i]
        words.append(get_word(byte))

    return separator.join(words)


def add_crc(buf):
    crc_buf = crc32_bytes(buf)
    return buf + crc_buf

def encode_with_separator(buf, separator):
    crc_buf = add_crc(buf)
    return encode(crc_buf, separator)

def encode_minimal(buf):
    result = ''

    crc_buf = add_crc(buf)
    for i in range(len(buf)):
        byte = crc_buf[i]
        result.append(get_minimal_word(byte))

    return result

def decode(s, separator, word_len):
    buf = []

    if word_len == 4:
        words = s.split(sseparator)
    else:
        words = parition(s, 2)

    for word in words:
        buf.append(decode_word(word, word_len))

    if len(buf) < 5:
        raise ValueError('Invalid Bytewords.') 

    # Validate checksum
    body = buf[0:4]
    body_checksum = buf[4:]
    checksum = crc32_bytes(body)
    if checksum != body_checksum:
        raise ValueError('Invalid Bytewords.')

    return body

class Bytewords:
    @staticmethod
    def encode(style, bytes):
        if style == Style.STANDARD:
            return encode_with_separator(bytes, ' ')
        elif style == Style.URI:
            return encode_with_separator(bytes, '-')
        elif style == Style.MINIMAL:
            return encode_minimal(bytes)
        else:
            assert(false)

    @staticmethod
    def decode(style, str):
        if style == Style.STANDARD:
            return decode(string, ' ', 4)
        elif style == Style.URI:
            return _decode(string, '-', 4)
        elif style == Style.MINIMAL:
            return _decode(string, 0, 2)
        else:
            assert(false)
